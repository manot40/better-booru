// Generated by dts-bundle-generator v9.5.1

import { Elysia } from 'elysia';

interface RequestInfo$1 {
  headers: {
    get: (key: string) => string | null;
  };
  method: string;
  url: string;
}
export type LogLevel = 'INFO' | 'WARNING' | 'ERROR' | ({} & string);
export interface LogData {
  status?: number;
  message?: string;
}
export type LogPayload = {
  data: LogData | string;
  level: LogLevel;
  store?: StoreData;
  request?: RequestInfo$1;
  options?: Options;
  useColors?: boolean;
};
export interface StoreData {
  beforeTime: bigint;
}
export interface TransportFunction {
  (
    level: LogLevel,
    message: string,
    meta: Pick<LogPayload, 'data' | 'store' | 'request'>
  ): Promise<void> | void;
}
export interface Transport {
  log: TransportFunction;
}
export interface TimestampConfig {
  translateTime?: boolean | string;
}
export interface Options {
  config?: {
    customLogFormat?: string;
    logFilePath?: string;
    logFilter?: {
      level?: LogLevel | LogLevel[];
      method?: string | string[];
      status?: number | number[];
    } | null;
    ip?: boolean;
    useColors?: boolean;
    showStartupMessage?: boolean;
    startupMessageFormat?: 'banner' | 'simple';
    transports?: Transport[];
    timestamp?: TimestampConfig; // Add this new option
  };
}
export declare type Rating = 'g' | 's' | 'q' | 'e';
export declare type RatingQuery = Rating | `-${Rating}` | 'all';
export declare type Provider = 'danbooru' | 'gelbooru';
export declare interface UserConfig {
  column?: 1 | 2 | 3 | 4;
  rating?: RatingQuery[];
  provider: Provider;
  hideNSFW?: boolean;
  browseMode?: 'infinite' | 'paginated';
  historyMode?: 'url_query' | 'session' | 'cookie';
}
declare const app: Elysia<
  '',
  {
    decorator: {
      log: (level: LogLevel, data: LogData | string) => void;
      logRequest: (opts: Omit<LogPayload, 'options'>) => void;
    };
    store: {
      cron: Record<'scrap', import('croner').Cron> &
        Record<'lqip_worker', import('croner').Cron> &
        Record<'ipx_cleanup_worker', import('croner').Cron>;
      beforeTime: bigint;
      cacheTTL: number | undefined;
    };
    derive: {
      setETag: (etag: string) => void;
      buildETagFor: (response: Bun.StringOrBuffer) => string;
      isMatch: (etag: string) => boolean;
      isNoneMatch: (etag: string) => boolean;
      setVary: (headers: string | string[]) => void;
    };
    resolve: {};
  },
  {
    typebox: {};
    error: {};
  },
  {
    schema: {};
    standaloneSchema: {};
    macro: {};
    macroFn: {};
    parser: {};
    response: {};
  },
  {
    scrap: {
      stop: {
        get: {
          body: unknown;
          params: {};
          query: unknown;
          headers: unknown;
          response: {
            200: 'Success' | 'Failed' | 'Not Running';
            401: 'Unauthorized';
          };
        };
      };
    };
  } & {
    scrap: {
      start: {
        get: {
          body: unknown;
          params: {};
          query: unknown;
          headers: unknown;
          response: {
            200: 'Success' | 'Failed' | 'Already Running';
            401: 'Unauthorized';
          };
        };
      };
    };
  } & {
    scrap: {
      trigger: {
        get: {
          body: unknown;
          params: {};
          query: unknown;
          headers: unknown;
          response: {
            200: 'Success' | 'Currently Working';
            401: 'Unauthorized';
          };
        };
      };
    };
  } & {
    scrap: {
      status: {
        get: {
          body: unknown;
          params: {};
          query: unknown;
          headers: unknown;
          response: {
            200: {
              isRunning: boolean;
              previous: Date | null;
              next: Date[];
            };
            401: 'Unauthorized';
          };
        };
      };
    };
  } & {
    image: {
      '*': {
        get: {
          body: unknown;
          params: {
            '*': string;
          };
          query: unknown;
          headers: unknown;
          response: {
            200: string | ArrayBuffer | Response | Buffer<ArrayBufferLike>;
            422: {
              type: 'validation';
              on: string;
              summary?: string;
              message?: string;
              found?: unknown;
              property?: string;
              expected?: string;
            };
          };
        };
      };
    };
  } & {
    api: {
      posts: {
        get: {
          body: unknown;
          params: {};
          query: {
            tags?: string | undefined;
            limit?: number | undefined;
            page?: string | number | undefined;
          };
          headers: unknown;
          response: {
            200: {
              meta: {
                limit: number;
                offset: number;
                count: number;
              };
              post: {
                tags?:
                  | {
                      name: string;
                      id: number;
                      category: 0 | 1 | 2 | 4 | 3 | 5;
                    }[]
                  | undefined;
                hash: string;
                id: number;
                lqip: string | null | undefined;
                score: number;
                source: string | null | undefined;
                rating: 'g' | 's' | 'q' | 'e';
                preview_width: number;
                preview_height: number;
                sample_width: number | null | undefined;
                sample_height: number | null | undefined;
                width: number;
                height: number;
                file_ext: string;
                file_size: number;
                pixiv_id: number | null | undefined;
                parent_id: number | null | undefined;
                has_notes: boolean;
                created_at: string;
                sample_url: string | null | undefined;
                file_url: string;
                preview_url: string;
              }[];
            };
            422: {
              type: 'validation';
              on: string;
              summary?: string;
              message?: string;
              found?: unknown;
              property?: string;
              expected?: string;
            };
          };
        };
      };
    };
  } & {
    api: {
      posts: {
        ':id': {
          get: {
            body: unknown;
            params: {
              id: number;
            };
            query: unknown;
            headers: unknown;
            response: {
              200: {
                tags?:
                  | {
                      name: string;
                      id: number;
                      category: 0 | 1 | 2 | 4 | 3 | 5;
                    }[]
                  | undefined;
                hash: string;
                id: number;
                lqip: string | null | undefined;
                score: number;
                source: string | null | undefined;
                rating: 'g' | 's' | 'q' | 'e';
                preview_width: number;
                preview_height: number;
                sample_width: number | null | undefined;
                sample_height: number | null | undefined;
                width: number;
                height: number;
                file_ext: string;
                file_size: number;
                pixiv_id: number | null | undefined;
                parent_id: number | null | undefined;
                has_notes: boolean;
                created_at: string;
                sample_url: string | null | undefined;
                file_url: string;
                preview_url: string;
              };
              422: {
                type: 'validation';
                on: string;
                summary?: string;
                message?: string;
                found?: unknown;
                property?: string;
                expected?: string;
              };
            };
          };
        };
      };
    };
  } & {
    api: {
      posts: {
        ':id': {
          tags: {
            get: {
              body: unknown;
              params: {
                id: number;
              };
              query: unknown;
              headers: unknown;
              response: {
                200: {
                  name: string;
                  id: number;
                  category: 0 | 1 | 2 | 4 | 3 | 5;
                }[];
                422: {
                  type: 'validation';
                  on: string;
                  summary?: string;
                  message?: string;
                  found?: unknown;
                  property?: string;
                  expected?: string;
                };
              };
            };
          };
        };
      };
    };
  } & {
    api: {
      autocomplete: {
        get: {
          body: unknown;
          params: {};
          query: {
            provider?: 'danbooru' | 'gelbooru' | undefined;
            q: string;
          };
          headers: unknown;
          response: {
            200: {
              post_count?: number | undefined;
              value: string;
              category: 0 | 1 | 2 | 4 | 3 | 5;
              label: string;
            }[];
            422: {
              type: 'validation';
              on: string;
              summary?: string;
              message?: string;
              found?: unknown;
              property?: string;
              expected?: string;
            };
          };
        };
      };
    };
  },
  {
    derive: {};
    resolve: {};
    schema: {};
    standaloneSchema: {};
    response: {
      200: import('elysia').ElysiaFile;
    };
  },
  {
    derive: {
      readonly userConfig?: UserConfig | undefined;
      readonly resolveTime: number;
    };
    resolve: {};
    schema: {};
    standaloneSchema: {};
    response: {};
  }
>;
export type Backend = typeof app;

export {};
